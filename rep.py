# -*- coding: utf-8 -*-
"""Rep.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_v9dtWQbDTZbSR8izigh0BDSDzlKqagW

# **Import deque for efficient queue operations**
"""

from collections import deque
pakistan_cities = {
    'Karachi': ['Hyderabad', 'Quetta'],
    'Hyderabad': ['Karachi', 'Sukkur'],
    'Sukkur': ['Hyderabad', 'Multan', 'Quetta'],
    'Multan': ['Sukkur', 'Lahore'],
    'Quetta': ['Karachi', 'Sukkur', 'Islamabad'],
    'Lahore': ['Multan', 'Islamabad'],
    'Islamabad': ['Lahore', 'Peshawar', 'Quetta'],
    'Peshawar': ['Islamabad']
}

"""# **BFS**"""

def bfs_shortest_path(g, s, G):
    queue = deque([[s]])
    visited = set()
    while queue:
        path = queue.popleft()
        current_city = path[-1]
        if current_city == G:
            return path
        if current_city not in visited:
            visited.add(current_city)

    for neighbor in g.get(current_city, []):
        new_path = list(path)
        new_path.append(neighbor)
        queue.append(new_path)
    return None

"""# **DFS**"""

def dfs_path(graph, start, goal, path=None, visited=None):
    if path is None:
        path = []
    if visited is None:
        visited = set()

    path.append(start)
    visited.add(start)

    if start == goal:
        return path

    for neighbor in graph.get(start, []):
        if neighbor not in visited:
            result = dfs_path(graph, neighbor, goal, path.copy(), visited)  # keep same visited
            if result:
                return result
    return None

"""# **Testing the Function**"""

s_city = "Karachi"
g_city = "Peshawar"

bfs_result = bfs_shortest_path(pakistan_cities, s_city, g_city)
dfs_result = dfs_path(pakistan_cities, s_city, g_city)

print("BFS Shortest Path from Karachi to Peshawar:", bfs_result)
print("DFS Path from Karachi to Peshawar:", dfs_result)